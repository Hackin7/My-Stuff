<h1>Description</h1>
<p>A node.js module for parsing incoming HTML form data.</p>
<p>If you've found this module to be useful and wish to support it, you may do so by visiting this pledgie campaign:
<a href='https://pledgie.com/campaigns/28774'><img alt='Click here to support busboy' src='https://pledgie.com/campaigns/28774.png?skin_name=chrome' border='0'></a></p>
<h1>Requirements</h1>
<ul>
<li><a href="http://nodejs.org/">node.js</a> -- v0.8.0 or newer</li>
</ul>
<h1>Install</h1>
<pre><code>npm install busboy
</code></pre>
<h1>Examples</h1>
<ul>
<li>Parsing (multipart) with default options:</li>
</ul>
<p>```javascript
var http = require('http'),
    inspect = require('util').inspect;</p>
<p>var Busboy = require('busboy');</p>
<p>http.createServer(function(req, res) {
  if (req.method === 'POST') {
    var busboy = new Busboy({ headers: req.headers });
    busboy.on('file', function(fieldname, file, filename, encoding, mimetype) {
      console.log('File [' + fieldname + ']: filename: ' + filename + ', encoding: ' + encoding + ', mimetype: ' + mimetype);
      file.on('data', function(data) {
        console.log('File [' + fieldname + '] got ' + data.length + ' bytes');
      });
      file.on('end', function() {
        console.log('File [' + fieldname + '] Finished');
      });
    });
    busboy.on('field', function(fieldname, val, fieldnameTruncated, valTruncated, encoding, mimetype) {
      console.log('Field [' + fieldname + ']: value: ' + inspect(val));
    });
    busboy.on('finish', function() {
      console.log('Done parsing form!');
      res.writeHead(303, { Connection: 'close', Location: '/' });
      res.end();
    });
    req.pipe(busboy);
  } else if (req.method === 'GET') {
    res.writeHead(200, { Connection: 'close' });
    res.end('<html><head></head><body>\
               <form method="POST" enctype="multipart/form-data">\
                <input type="text" name="textfield"><br />\
                <input type="file" name="filefield"><br />\
                <input type="submit">\
              </form>\
            </body></html>');
  }
}).listen(8000, function() {
  console.log('Listening for requests');
});</p>
<p>// Example output, using http://nodejs.org/images/ryan-speaker.jpg as the file:
//
// Listening for requests
// File [filefield]: filename: ryan-speaker.jpg, encoding: binary
// File [filefield] got 11971 bytes
// Field [textfield]: value: 'testing! :-)'
// File [filefield] Finished
// Done parsing form!
```</p>
<ul>
<li>Save all incoming files to disk:</li>
</ul>
<p>```javascript
var http = require('http'),
    path = require('path'),
    os = require('os'),
    fs = require('fs');</p>
<p>var Busboy = require('busboy');</p>
<p>http.createServer(function(req, res) {
  if (req.method === 'POST') {
    var busboy = new Busboy({ headers: req.headers });
    busboy.on('file', function(fieldname, file, filename, encoding, mimetype) {
      var saveTo = path.join(os.tmpDir(), path.basename(fieldname));
      file.pipe(fs.createWriteStream(saveTo));
    });
    busboy.on('finish', function() {
      res.writeHead(200, { 'Connection': 'close' });
      res.end("That's all folks!");
    });
    return req.pipe(busboy);
  }
  res.writeHead(404);
  res.end();
}).listen(8000, function() {
  console.log('Listening for requests');
});
```</p>
<ul>
<li>Parsing (urlencoded) with default options:</li>
</ul>
<p>```javascript
var http = require('http'),
    inspect = require('util').inspect;</p>
<p>var Busboy = require('busboy');</p>
<p>http.createServer(function(req, res) {
  if (req.method === 'POST') {
    var busboy = new Busboy({ headers: req.headers });
    busboy.on('file', function(fieldname, file, filename, encoding, mimetype) {
      console.log('File [' + fieldname + ']: filename: ' + filename);
      file.on('data', function(data) {
        console.log('File [' + fieldname + '] got ' + data.length + ' bytes');
      });
      file.on('end', function() {
        console.log('File [' + fieldname + '] Finished');
      });
    });
    busboy.on('field', function(fieldname, val, fieldnameTruncated, valTruncated) {
      console.log('Field [' + fieldname + ']: value: ' + inspect(val));
    });
    busboy.on('finish', function() {
      console.log('Done parsing form!');
      res.writeHead(303, { Connection: 'close', Location: '/' });
      res.end();
    });
    req.pipe(busboy);
  } else if (req.method === 'GET') {
    res.writeHead(200, { Connection: 'close' });
    res.end('<html><head></head><body>\
               <form method="POST">\
                <input type="text" name="textfield"><br />\
                <select name="selectfield">\
                  <option value="1">1</option>\
                  <option value="10">10</option>\
                  <option value="100">100</option>\
                  <option value="9001">9001</option>\
                </select><br />\
                <input type="checkbox" name="checkfield">Node.js rules!<br />\
                <input type="submit">\
              </form>\
            </body></html>');
  }
}).listen(8000, function() {
  console.log('Listening for requests');
});</p>
<p>// Example output:
//
// Listening for requests
// Field [textfield]: value: 'testing! :-)'
// Field [selectfield]: value: '9001'
// Field [checkfield]: value: 'on'
// Done parsing form!
```</p>
<h1>API</h1>
<p><em>Busboy</em> is a <em>Writable</em> stream</p>
<h2>Busboy (special) events</h2>
<ul>
<li>
<p><strong>file</strong>(&lt; <em>string</em> &gt;fieldname, &lt; <em>ReadableStream</em> &gt;stream, &lt; <em>string</em> &gt;filename, &lt; <em>string</em> &gt;transferEncoding, &lt; <em>string</em> &gt;mimeType) - Emitted for each new file form field found. <code>transferEncoding</code> contains the 'Content-Transfer-Encoding' value for the file stream. <code>mimeType</code> contains the 'Content-Type' value for the file stream.</p>
<ul>
<li>Note: if you listen for this event, you should always handle the <code>stream</code> no matter if you care about the file contents or not (e.g. you can simply just do <code>stream.resume();</code> if you want to discard the contents), otherwise the 'finish' event will never fire on the Busboy instance. However, if you don't care about <strong>any</strong> incoming files, you can simply not listen for the 'file' event at all and any/all files will be automatically and safely discarded (these discarded files do still count towards <code>files</code> and <code>parts</code> limits).</li>
<li>If a configured file size limit was reached, <code>stream</code> will both have a boolean property <code>truncated</code> (best checked at the end of the stream) and emit a 'limit' event to notify you when this happens.</li>
</ul>
</li>
<li>
<p><strong>field</strong>(&lt; <em>string</em> &gt;fieldname, &lt; <em>string</em> &gt;value, &lt; <em>boolean</em> &gt;fieldnameTruncated, &lt; <em>boolean</em> &gt;valueTruncated, &lt; <em>string</em> &gt;transferEncoding, &lt; <em>string</em> &gt;mimeType) - Emitted for each new non-file field found.</p>
</li>
<li>
<p><strong>partsLimit</strong>() - Emitted when specified <code>parts</code> limit has been reached. No more 'file' or 'field' events will be emitted.</p>
</li>
<li>
<p><strong>filesLimit</strong>() - Emitted when specified <code>files</code> limit has been reached. No more 'file' events will be emitted.</p>
</li>
<li>
<p><strong>fieldsLimit</strong>() - Emitted when specified <code>fields</code> limit has been reached. No more 'field' events will be emitted.</p>
</li>
</ul>
<h2>Busboy methods</h2>
<ul>
<li>
<p><strong>(constructor)</strong>(&lt; <em>object</em> &gt;config) - Creates and returns a new Busboy instance.</p>
<ul>
<li>
<p>The constructor takes the following valid <code>config</code> settings:</p>
<ul>
<li>
<p><strong>headers</strong> - <em>object</em> - These are the HTTP headers of the incoming request, which are used by individual parsers.</p>
</li>
<li>
<p><strong>highWaterMark</strong> - <em>integer</em> - highWaterMark to use for this Busboy instance (Default: WritableStream default).</p>
</li>
<li>
<p><strong>fileHwm</strong> - <em>integer</em> - highWaterMark to use for file streams (Default: ReadableStream default).</p>
</li>
<li>
<p><strong>defCharset</strong> - <em>string</em> - Default character set to use when one isn't defined (Default: 'utf8').</p>
</li>
<li>
<p><strong>preservePath</strong> - <em>boolean</em> - If paths in the multipart 'filename' field shall be preserved. (Default: false).</p>
</li>
<li>
<p><strong>limits</strong> - <em>object</em> - Various limits on incoming data. Valid properties are:</p>
<ul>
<li>
<p><strong>fieldNameSize</strong> - <em>integer</em> - Max field name size (in bytes) (Default: 100 bytes).</p>
</li>
<li>
<p><strong>fieldSize</strong> - <em>integer</em> - Max field value size (in bytes) (Default: 1MB).</p>
</li>
<li>
<p><strong>fields</strong> - <em>integer</em> - Max number of non-file fields (Default: Infinity).</p>
</li>
<li>
<p><strong>fileSize</strong> - <em>integer</em> - For multipart forms, the max file size (in bytes) (Default: Infinity).</p>
</li>
<li>
<p><strong>files</strong> - <em>integer</em> - For multipart forms, the max number of file fields (Default: Infinity).</p>
</li>
<li>
<p><strong>parts</strong> - <em>integer</em> - For multipart forms, the max number of parts (fields + files) (Default: Infinity).</p>
</li>
<li>
<p><strong>headerPairs</strong> - <em>integer</em> - For multipart forms, the max number of header key=&gt;value pairs to parse <strong>Default:</strong> 2000 (same as node's http).</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>The constructor can throw errors:</p>
<ul>
<li>
<p><strong>Unsupported content type: $type</strong> - The <code>Content-Type</code> isn't one Busboy can parse.</p>
</li>
<li>
<p><strong>Missing Content-Type</strong> - The provided headers don't include <code>Content-Type</code> at all.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>